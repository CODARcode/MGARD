#include <cmath>
#include <cstddef>

#include <iostream>

#include "mgard/compress.hpp"

// This program illustrates the use of MGARD's compression API. We begin by
// generating a dataset to be compressed. The dataset will consist of `N`
// samples of a function `f` at uniformly spaced points on an interval `[a, b)`.

// Left endpoint of the interval.
const float a = 0;

// Right endpoint of the interval.
const float b = 2 * 4 * std::atan(1.f);

// Number of samples (size of the dataset).
const std::size_t N = 1000;

// Function to be sampled.
float f(const float x) { return 5 * std::sin(3 * x) - 2 * std::cos(7 * x); }

int main() {
  // Buffer for the dataset.
  float *const u = new float[N];

  std::cout << "generating data ...";
  for (std::size_t i = 0; i < N; ++i) {
    u[i] = (b - a) / N * i;
  }
  std::cout << " done" << std::endl;

  // We will need to tell MGARD the dimension and shape of the dataset. This
  // information is contained in an `mgard::TensorMeshHierarchy`. The first
  // template parameter is the dimension. The second is the datatype. `{N}` is
  // the shape of the dataset.
  std::cout << "creating mesh hierarchy ...";
  const mgard::TensorMeshHierarchy<1, float> hierarchy({N});
  std::cout << " done" << std::endl;

  // Next we set the compression parameters. First we select the norm in which
  // to control the compression error. We choose from the family of supported
  // norms by setting a smoothness parameter `s`. `s = 0` corresponds to the
  // `L²` norm.
  const float s = 0;
  // Next we set the absolute error tolerance `τ`. The approximating dataset `ũ`
  // generated by MGARD will satisfy `‖u - ũ‖_{L^2} ≤ τ`.
  const float tolerance = 0.000001;
  std::cout << "compressing ...";
  const mgard::CompressedDataset<1, float> compressed =
      mgard::compress(hierarchy, u, s, tolerance);
  std::cout << " done" << std::endl;

  // `compressed` contains the compressed data buffer. We can query its size in
  // bytes with the `size` member function.
  std::cout << "compression ratio: "
            << static_cast<float>(N * sizeof(*u)) / compressed.size()
            << std::endl;
  // If we needed the values of the approximating dataset `ũ`, we'd apply
  // `mgard::decompress` to `compressed`.

  delete[] u;
  return 0;
}
