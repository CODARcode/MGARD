#include <cmath>
#include <cstddef>

#include <algorithm>
#include <array>
#include <iostream>
#include <vector>

#include "mgard/compress.hpp"

// This program illustrates the use of MGARD's compression API. The dataset to
// be compressed will consist of `N` samples of a function `f` at uniformly
// spaced points on an interval `[a, b)`.

// Left endpoint of the interval.
const float a = 0;

// Right endpoint of the interval.
const float b = 2 * 4 * std::atan(1.f);

// Number of samples (size of the dataset).
const std::size_t N = 1000;

// Function to be sampled.
float f(const float x) { return 5 * std::sin(3 * x) - 2 * std::cos(7 * x); }

int main() {
  // Conceptually, MGARD operates on functions, not 'raw' arrays. A dataset is
  // passed to `mgard::compress` as an array of function samples at points in a
  // mesh. To make sense of the samples, MGARD needs the mesh. MGARD supports
  // Cartesian meshes, meaning point sets of the form `{(x_{i}, y_{j}, …) :
  // 0 ≤ i < n, 0 ≤ j < m, …}`. Such a mesh can be encoded by the coordinate
  // array `{{x_{0}, …, x_{n - 1}}, {y_{0}, …, y_{m - 1}}, …}`.

  // Coordinate array.
  std::array<std::vector<float>, 1> coordinates;
  std::vector<float> &x = coordinates.at(0);
  x.reserve(N);
  std::cout << "generating coordinate array ...";
  for (std::size_t i = 0; i < N; ++i) {
    x.push_back((b - a) / N * i);
  }
  std::cout << " done" << std::endl;

  // We wrap the information about the mesh into an `mgard::TensorMeshHierarchy`
  // object. The first template parameter is the dimension. The second is the
  // datatype. `{N}` is the shape of the mesh/dataset, and `coordinates` is the
  // coordinate array. If the coordinate array is omitted, a uniform mesh on
  // `[0, 1]^{d}` will be used.
  std::cout << "creating mesh hierarchy ...";
  const mgard::TensorMeshHierarchy<1, float> hierarchy({N}, coordinates);
  std::cout << " done" << std::endl;

  // Next we sample `f` at the mesh points to generate the dataset.

  // Buffer for the dataset.
  float *const u = new float[N];
  std::cout << "generating data ...";
  std::transform(x.begin(), x.end(), u, f);
  std::cout << " done" << std::endl;

  // Now we set the compression parameters. First we select the norm in which to
  // control the compression error. We choose from the family of supported norms
  // by setting a smoothness parameter `s`. `s = 0` corresponds to the `L²`
  // norm.
  const float s = 0;
  // Next we set the absolute error tolerance `τ`. The approximating dataset `ũ`
  // generated by MGARD will satisfy `‖u - ũ‖_{L²} ≤ τ`.
  const float tolerance = 0.000001;

  // We can now compress `u`. To do this, pass the mesh hierarchy, the function,
  // the smoothness parameter, and the error tolerance to `mgard::compress`.
  std::cout << "compressing ...";
  const mgard::CompressedDataset<1, float> compressed =
      mgard::compress(hierarchy, u, s, tolerance);
  std::cout << " done" << std::endl;

  // `compressed` contains the compressed data buffer. We can query its size in
  // bytes with the `size` member function.
  std::cout << "compression ratio: "
            << static_cast<float>(N * sizeof(*u)) / compressed.size()
            << std::endl;
  // If we needed the values of the approximating dataset `ũ`, we'd apply
  // `mgard::decompress` to `compressed`.

  delete[] u;
  return 0;
}
